<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Pac-like Mobile Game - Classic Layout</title>
  <style>
    :root{
      --bg: #000;
      --maze-bg: #000;
      --wall-color: #0000ff;
      --pellet-color: #ffff00;
      --player-color: #ffff00;
      --hud-bg: #000;
      --hud-text: #ffff00;
    }

    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--hud-text);
      font-family: 'Courier New', monospace;
      -webkit-font-smoothing:antialiased;
      -webkit-tap-highlight-color: transparent;
      overflow: hidden;
    }

    #game-container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    /* Main game area - takes most of the screen */
    #game-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--maze-bg);
      position: relative;
    }

    #game-canvas{
      background: var(--maze-bg);
      display: block;
      border: 2px solid var(--wall-color);
    }

    /* Right sidebar - HUD and controls */
    #hud-panel {
      width: 200px;
      background: var(--hud-bg);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      border-left: 2px solid var(--wall-color);
    }

    .hud-section {
      text-align: center;
    }

    .hud-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #ff0000;
    }

    .hud-value {
      font-size: 24px;
      font-weight: bold;
      margin: 5px 0;
    }

    .hud-label {
      font-size: 14px;
      margin: 2px 0;
    }

    /* Mobile controls in HUD */
    #mobile-controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap: 5px;
      width: 120px;
      height: 120px;
      margin: 0 auto;
    }

    .control-btn {
      background: var(--wall-color);
      border: 2px solid var(--hud-text);
      color: var(--hud-text);
      font-size: 20px;
      font-weight: bold;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #btn-up { grid-column: 2; grid-row: 1; }
    #btn-left { grid-column: 1; grid-row: 2; }
    #btn-right { grid-column: 3; grid-row: 2; }
    #btn-down { grid-column: 2; grid-row: 3; }

    #start-btn, #sound-btn {
      background: var(--pellet-color);
      color: var(--bg);
      border: none;
      padding: 10px;
      font-weight: bold;
      border-radius: 5px;
      cursor: pointer;
    }

    /* Lives display */
    #lives-display {
      display: flex;
      justify-content: center;
      gap: 5px;
    }

    .life-icon {
      width: 20px;
      height: 20px;
      background: var(--player-color);
      border-radius: 50%;
      position: relative;
    }

    .life-icon::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-left: 8px solid var(--bg);
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      transform: translate(-50%, -50%);
    }

    /* Game overlay messages */
    #game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #game-message {
      background: var(--bg);
      padding: 30px;
      border: 3px solid var(--pellet-color);
      text-align: center;
      color: var(--hud-text);
    }

    #continue-btn {
      margin-top: 15px;
      padding: 10px 20px;
      background: var(--pellet-color);
      color: var(--bg);
      border: none;
      font-weight: bold;
      cursor: pointer;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      #game-container {
        flex-direction: column;
      }
      
      #hud-panel {
        width: 100%;
        height: 150px;
        flex-direction: row;
        justify-content: space-around;
        align-items: center;
        border-left: none;
        border-top: 2px solid var(--wall-color);
      }
      
      #mobile-controls {
        width: 100px;
        height: 100px;
      }
      
      .hud-section {
        flex: 1;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="game-area">
      <canvas id="game-canvas"></canvas>
      
      <div id="game-overlay">
        <div id="game-message">
          <h2 id="message-title">Level Complete!</h2>
          <p id="message-text">Great job! Ready for the next level?</p>
          <button id="continue-btn">Continue</button>
        </div>
      </div>
    </div>

    <div id="hud-panel">
      <div class="hud-section">
        <div class="hud-title">SCORE</div>
        <div id="score-display" class="hud-value">0</div>
        
        <div class="hud-title" style="margin-top: 15px;">LEVEL</div>
        <div id="level-display" class="hud-value">1</div>
        
        <div class="hud-title" style="margin-top: 15px;">LIVES</div>
        <div id="lives-display"></div>
        
        <div class="hud-label" style="margin-top: 15px;">Pellets Left:</div>
        <div id="pellets-display" class="hud-value">0</div>
      </div>

      <div class="hud-section">
        <div class="hud-title">CONTROLS</div>
        <div id="mobile-controls">
          <button id="btn-up" class="control-btn" data-dir="up">▲</button>
          <button id="btn-left" class="control-btn" data-dir="left">◀</button>
          <button id="btn-right" class="control-btn" data-dir="right">▶</button>
          <button id="btn-down" class="control-btn" data-dir="down">▼</button>
        </div>
        
        <button id="start-btn" style="margin-top: 15px; width: 100%;">START GAME</button>
        <button id="sound-btn" style="margin-top: 5px; width: 100%;">SOUND: ON</button>
      </div>
    </div>
  </div>

  <script>
    // Sound effects using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let soundEnabled = true;

    // Sound generation functions
    function createTone(frequency, duration, type = 'square') {
      if (!soundEnabled) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      oscillator.type = type;
      
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }

    // Sound effects
    const sounds = {
      chomp: () => {
        createTone(800, 0.1);
        setTimeout(() => createTone(600, 0.1), 50);
      },
      death: () => {
        for (let i = 0; i < 10; i++) {
          setTimeout(() => createTone(400 - i * 30, 0.1), i * 50);
        }
      },
      levelComplete: () => {
        const notes = [523, 659, 784, 1047];
        notes.forEach((note, i) => {
          setTimeout(() => createTone(note, 0.3, 'sine'), i * 150);
        });
      },
      ghostMove: () => {
        createTone(200, 0.05, 'sawtooth');
      }
    };

    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');

    const COLS = 25;
    const ROWS = 25;
    const TILE = 20;
    const VIRTUAL_W = COLS * TILE;
    const VIRTUAL_H = ROWS * TILE;

    // Game state
    let gameRunning = false;
    let currentLevel = 1;
    let score = 0;
    let lives = 3;
    let pelletsRemaining = 0;

    function generateMap() {
      const newMap = new Array(ROWS).fill(0).map((_, r) => {
        return new Array(COLS).fill(0).map((_, c) => {
          // Create more interesting maze pattern
          if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) return 1;
          if ((r % 4 === 0 || c % 4 === 0) && Math.random() > 0.3) return 1;
          if (r > 10 && r < 14 && c > 10 && c < 14) return 0; // Ghost home area
          return 2;
        });
      });
      
      pelletsRemaining = 0;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (newMap[r][c] === 2) pelletsRemaining++;
        }
      }
      
      return newMap;
    }

    let map = generateMap();

    const player = {
      x: TILE * 1.5,
      y: TILE * 1.5,
      radius: TILE * 0.4,
      dir: null,
      nextDir: null,
      speed: 100,
    };

    const ghostColors = ['#ff0000', '#ffb8ff', '#00ffff', '#ffb852'];
    const ghostBehaviors = ['chase', 'ambush', 'patrol', 'random'];
    let ghosts = [];

    function createGhost(index, level) {
      const startPositions = [
        {x: TILE * 12, y: TILE * 12},
        {x: TILE * 13, y: TILE * 12},
        {x: TILE * 12, y: TILE * 13},
        {x: TILE * 13, y: TILE * 13}
      ];
      
      return {
        x: startPositions[index % 4].x,
        y: startPositions[index % 4].y,
        radius: TILE * 0.35,
        dir: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
        speed: 70 + (level * 10),
        color: ghostColors[index % 4],
        behavior: ghostBehaviors[index % 4],
        changeTimer: 0,
        moveSound: 0
      };
    }

    function updateHUD() {
      document.getElementById('score-display').textContent = score;
      document.getElementById('level-display').textContent = currentLevel;
      document.getElementById('pellets-display').textContent = pelletsRemaining;
      
      // Update lives display
      const livesContainer = document.getElementById('lives-display');
      livesContainer.innerHTML = '';
      for (let i = 0; i < lives; i++) {
        const lifeIcon = document.createElement('div');
        lifeIcon.className = 'life-icon';
        livesContainer.appendChild(lifeIcon);
      }
    }

    function initializeLevel(level) {
      map = generateMap();
      
      player.x = TILE * 1.5;
      player.y = TILE * 1.5;
      player.dir = null;
      player.nextDir = null;
      
      ghosts = [];
      const numGhosts = Math.min(4, Math.floor(level / 2) + 1);
      for (let i = 0; i < numGhosts; i++) {
        ghosts.push(createGhost(i, level));
      }
      
      updateHUD();
    }

    function resizeCanvas() {
      const container = document.getElementById('game-area');
      const maxW = container.clientWidth - 40;
      const maxH = container.clientHeight - 40;
      
      const scale = Math.min(maxW / VIRTUAL_W, maxH / VIRTUAL_H);
      const displayW = Math.floor(VIRTUAL_W * scale);
      const displayH = Math.floor(VIRTUAL_H * scale);
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      canvas.style.width = displayW + 'px';
      canvas.style.height = displayH + 'px';
      canvas.width = Math.floor(displayW * dpr);
      canvas.height = Math.floor(displayH * dpr);

      ctx.setTransform(dpr * scale, 0, 0, dpr * scale, 0, 0);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Input handling
    const keys = {};
    window.addEventListener('keydown', e => {
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      
      const mapKey = {ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', a:'left', s:'down', d:'right'}[e.key];
      if (mapKey) { keys[mapKey] = true; e.preventDefault(); }
    });
    window.addEventListener('keyup', e => {
      const mapKey = {ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', a:'left', s:'down', d:'right'}[e.key];
      if (mapKey) keys[mapKey] = false;
    });

    // Touch controls
    document.querySelectorAll('.control-btn').forEach(btn => {
      const dir = btn.dataset.dir;
      btn.addEventListener('touchstart', e => { 
        keys[dir] = true; 
        e.preventDefault();
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
      }, {passive:false});
      btn.addEventListener('touchend', e => { keys[dir] = false; e.preventDefault(); }, {passive:false});
      btn.addEventListener('mousedown', e => { keys[dir] = true; e.preventDefault(); });
      btn.addEventListener('mouseup', e => { keys[dir] = false; e.preventDefault(); });
    });

    // Sound toggle
    document.getElementById('sound-btn').addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      document.getElementById('sound-btn').textContent = `SOUND: ${soundEnabled ? 'ON' : 'OFF'}`;
    });

    function tileAt(c, r) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return 1;
      return map[r][c];
    }

    function collides(x, y, r) {
      const left = Math.floor((x - r) / TILE);
      const right = Math.floor((x + r) / TILE);
      const top = Math.floor((y - r) / TILE);
      const bottom = Math.floor((y + r) / TILE);
      for (let rr = top; rr <= bottom; rr++) {
        for (let cc = left; cc <= right; cc++) {
          if (tileAt(cc, rr) === 1) return true;
        }
      }
      return false;
    }

    function distance(x1, y1, x2, y2) {
      return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
    }

    function updateGhost(ghost, dt) {
      ghost.changeTimer -= dt;
      ghost.moveSound -= dt;
      
      if (ghost.moveSound <= 0) {
        ghost.moveSound = 0.5;
        if (Math.random() < 0.1) sounds.ghostMove();
      }
      
      const aggressiveness = Math.min(1, currentLevel / 10);
      
      if (ghost.changeTimer <= 0) {
        ghost.changeTimer = 1 + Math.random() * 2;
        
        switch (ghost.behavior) {
          case 'chase':
            if (player.x > ghost.x) ghost.dir = 'right';
            else if (player.x < ghost.x) ghost.dir = 'left';
            else if (player.y > ghost.y) ghost.dir = 'down';
            else ghost.dir = 'up';
            break;
            
          case 'ambush':
            let targetX = player.x;
            let targetY = player.y;
            if (player.dir === 'up') targetY -= TILE * 4;
            else if (player.dir === 'down') targetY += TILE * 4;
            else if (player.dir === 'left') targetX -= TILE * 4;
            else if (player.dir === 'right') targetX += TILE * 4;
            
            if (targetX > ghost.x) ghost.dir = 'right';
            else if (targetX < ghost.x) ghost.dir = 'left';
            else if (targetY > ghost.y) ghost.dir = 'down';
            else ghost.dir = 'up';
            break;
            
          case 'patrol':
            if (Math.random() < 0.3 + aggressiveness * 0.4) {
              if (Math.abs(player.x - ghost.x) > Math.abs(player.y - ghost.y)) {
                ghost.dir = player.x > ghost.x ? 'right' : 'left';
              } else {
                ghost.dir = player.y > ghost.y ? 'down' : 'up';
              }
            } else {
              ghost.dir = ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)];
            }
            break;
            
          case 'random':
            if (Math.random() < aggressiveness * 0.5) {
              if (player.x > ghost.x) ghost.dir = 'right';
              else if (player.x < ghost.x) ghost.dir = 'left';
              else if (player.y > ghost.y) ghost.dir = 'down';
              else ghost.dir = 'up';
            } else {
              ghost.dir = ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)];
            }
            break;
        }
      }
      
      const vx = ghost.dir === 'left' ? -1 : ghost.dir === 'right' ? 1 : 0;
      const vy = ghost.dir === 'up' ? -1 : ghost.dir === 'down' ? 1 : 0;
      const nx = ghost.x + vx * ghost.speed * dt;
      const ny = ghost.y + vy * ghost.speed * dt;
      
      if (!collides(nx, ny, ghost.radius - 1)) {
        ghost.x = nx;
        ghost.y = ny;
      } else {
        ghost.changeTimer = 0;
      }
    }

    let last = performance.now();
    function step(now) {
      if (gameRunning) {
        const dt = Math.min(0.05, (now - last) / 1000);
        last = now;
        update(dt);
        render();
      }
      requestAnimationFrame(step);
    }

    function update(dt) {
      const desire = keys.up ? 'up' : keys.down ? 'down' : keys.left ? 'left' : keys.right ? 'right' : null;
      if (desire) player.nextDir = desire;

      if (player.nextDir) {
        const dir = player.nextDir;
        const vx = dir === 'left' ? -1 : dir === 'right' ? 1 : 0;
        const vy = dir === 'up' ? -1 : dir === 'down' ? 1 : 0;
        const nx = player.x + vx * player.speed * dt;
        const ny = player.y + vy * player.speed * dt;
        if (!collides(nx, ny, player.radius - 1)) {
          player.dir = player.nextDir;
          player.nextDir = null;
        }
      }

      if (player.dir) {
        const vx = player.dir === 'left' ? -1 : player.dir === 'right' ? 1 : 0;
        const vy = player.dir === 'up' ? -1 : player.dir === 'down' ? 1 : 0;
        const nx = player.x + vx * player.speed * dt;
        const ny = player.y + vy * player.speed * dt;
        if (!collides(nx, ny, player.radius - 1)) {
          player.x = nx; player.y = ny;
        } else {
          player.dir = null;
        }
      }

      const col = Math.floor(player.x / TILE);
      const row = Math.floor(player.y / TILE);
      if (map[row] && map[row][col] === 2) {
        map[row][col] = 0;
        score += 10 * currentLevel;
        pelletsRemaining--;
        sounds.chomp();
        updateHUD();
        
        if (pelletsRemaining === 0) {
          gameRunning = false;
          sounds.levelComplete();
          if (currentLevel >= 10) {
            showGameMessage('🎉 VICTORY! 🎉', 'You completed all 10 levels!', 'PLAY AGAIN', () => {
              currentLevel = 1;
              lives = 3;
              score = 0;
              startGame();
            });
          } else {
            showGameMessage('LEVEL COMPLETE!', `Level ${currentLevel + 1} ready!`, 'NEXT LEVEL', () => {
              currentLevel++;
              initializeLevel(currentLevel);
              startGame();
            });
          }
        }
      }

      ghosts.forEach(ghost => updateGhost(ghost, dt));

      ghosts.forEach(ghost => {
        if (distance(player.x, player.y, ghost.x, ghost.y) < player.radius + ghost.radius - 2) {
          lives--;
          sounds.death();
          updateHUD();
          
          if (lives <= 0) {
            gameRunning = false;
            showGameMessage('GAME OVER!', `Final Score: ${score}`, 'RESTART', () => {
              currentLevel = 1;
              lives = 3;
              score = 0;
              startGame();
            });
          } else {
            player.x = TILE * 1.5;
            player.y = TILE * 1.5;
            player.dir = null;
            player.nextDir = null;
          }
        }
      });
    }

    function render() {
      ctx.clearRect(0, 0, VIRTUAL_W, VIRTUAL_H);
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, VIRTUAL_W, VIRTUAL_H);

      // Draw maze
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const t = map[r][c];
          const x = c * TILE, y = r * TILE;
          if (t === 1) {
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
          } else if (t === 2) {
            ctx.fillStyle = '#ffff00';
            const cx = x + TILE / 2, cy = y + TILE / 2;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      // Draw ghosts
      ghosts.forEach(ghost => {
        ctx.fillStyle = ghost.color;
        ctx.beginPath();
        ctx.arc(ghost.x, ghost.y, ghost.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(ghost.x - 5, ghost.y - 4, 3, 0, Math.PI * 2);
        ctx.arc(ghost.x + 5, ghost.y - 4, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(ghost.x - 5, ghost.y - 4, 1.5, 0, Math.PI * 2);
        ctx.arc(ghost.x + 5, ghost.y - 4, 1.5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw player (Pac-Man)
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.fillStyle = '#ffff00';
      const t = performance.now() / 150;
      const mouth = Math.abs(Math.sin(t)) * 0.4 + 0.1;
      let ang = 0;
      if (player.dir === 'left') ang = Math.PI;
      else if (player.dir === 'up') ang = -Math.PI / 2;
      else if (player.dir === 'down') ang = Math.PI / 2;
      const start = mouth * Math.PI + ang;
      const end = (2 - mouth) * Math.PI + ang;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, player.radius, start, end, false);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function showGameMessage(title, text, buttonText, callback) {
      document.getElementById('message-title').textContent = title;
      document.getElementById('message-text').textContent = text;
      document.getElementById('continue-btn').textContent = buttonText;
      document.getElementById('game-overlay').style.display = 'flex';
      
      document.getElementById('continue-btn').onclick = () => {
        document.getElementById('game-overlay').style.display = 'none';
        callback();
      };
    }

    function startGame() {
      initializeLevel(currentLevel);
      gameRunning = true;
      last = performance.now();
      requestAnimationFrame(step);
      document.getElementById('start-btn').textContent = 'RESTART';
    }

    document.getElementById('start-btn').addEventListener('click', () => {
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      startGame();
    });

    window.addEventListener('load', () => {
      resizeCanvas();
      initializeLevel(1);
      render();
    });
  </script>
</body>
</html>
