<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Pac-like Mobile Game - Enhanced</title>
  <style>
    :root{
      --bg: #000;
      --maze-bg: #000;
      --wall-color: #0000ff;
      --pellet-color: #ffff00;
      --player-color: #ffff00;
      --hud-bg: #000;
      --hud-text: #ffff00;
      --powerup-color: #ff6600;
    }

    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--hud-text);
      font-family: 'Courier New', monospace;
      -webkit-font-smoothing:antialiased;
      -webkit-tap-highlight-color: transparent;
      overflow: hidden;
    }

    #game-container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    #game-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--maze-bg);
      position: relative;
    }

    #game-canvas{
      background: var(--maze-bg);
      display: block;
      border: 2px solid var(--wall-color);
    }

    #hud-panel {
      width: 200px;
      background: var(--hud-bg);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      border-left: 2px solid var(--wall-color);
    }

    .hud-section {
      text-align: center;
    }

    .hud-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #ff0000;
    }

    .hud-value {
      font-size: 24px;
      font-weight: bold;
      margin: 5px 0;
    }

    .hud-label {
      font-size: 14px;
      margin: 2px 0;
    }

    #mobile-controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap: 5px;
      width: 120px;
      height: 120px;
      margin: 0 auto;
    }

    .control-btn {
      background: var(--wall-color);
      border: 2px solid var(--hud-text);
      color: var(--hud-text);
      font-size: 20px;
      font-weight: bold;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #btn-up { grid-column: 2; grid-row: 1; }
    #btn-left { grid-column: 1; grid-row: 2; }
    #btn-right { grid-column: 3; grid-row: 2; }
    #btn-down { grid-column: 2; grid-row: 3; }

    #start-btn, #sound-btn {
      background: var(--pellet-color);
      color: var(--bg);
      border: none;
      padding: 10px;
      font-weight: bold;
      border-radius: 5px;
      cursor: pointer;
    }

    #lives-display {
      display: flex;
      justify-content: center;
      gap: 5px;
    }

    .life-icon {
      width: 20px;
      height: 20px;
      background: var(--player-color);
      border-radius: 50%;
      position: relative;
    }

    .life-icon::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-left: 8px solid var(--bg);
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      transform: translate(-50%, -50%);
    }

    #game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #game-message {
      background: var(--bg);
      padding: 30px;
      border: 3px solid var(--pellet-color);
      text-align: center;
      color: var(--hud-text);
    }

    #continue-btn {
      margin-top: 15px;
      padding: 10px 20px;
      background: var(--pellet-color);
      color: var(--bg);
      border: none;
      font-weight: bold;
      cursor: pointer;
    }

    .powerup-timer {
      color: var(--powerup-color);
      font-weight: bold;
      animation: pulse 0.5s infinite alternate;
    }

    @keyframes pulse {
      from { opacity: 1; }
      to { opacity: 0.5; }
    }

    @media (max-width: 768px) {
      #game-container {
        flex-direction: column;
      }
      
      #hud-panel {
        width: 100%;
        height: 150px;
        flex-direction: row;
        justify-content: space-around;
        align-items: center;
        border-left: none;
        border-top: 2px solid var(--wall-color);
      }
      
      #mobile-controls {
        width: 100px;
        height: 100px;
      }
      
      .hud-section {
        flex: 1;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="game-area">
      <canvas id="game-canvas"></canvas>
      
      <div id="game-overlay">
        <div id="game-message">
          <h2 id="message-title">Level Complete!</h2>
          <p id="message-text">Great job! Ready for the next level?</p>
          <button id="continue-btn">Continue</button>
        </div>
      </div>
    </div>

    <div id="hud-panel">
      <div class="hud-section">
        <div class="hud-title">SCORE</div>
        <div id="score-display" class="hud-value">0</div>
        
        <div class="hud-title" style="margin-top: 15px;">LEVEL</div>
        <div id="level-display" class="hud-value">1</div>
        
        <div class="hud-title" style="margin-top: 15px;">LIVES</div>
        <div id="lives-display"></div>
        
        <div class="hud-label" style="margin-top: 15px;">Pellets:</div>
        <div id="pellets-display" class="hud-value">0</div>
        
        <div id="powerup-status" style="margin-top: 10px;"></div>
      </div>

      <div class="hud-section">
        <div class="hud-title">CONTROLS</div>
        <div id="mobile-controls">
          <button id="btn-up" class="control-btn" data-dir="up">▲</button>
          <button id="btn-left" class="control-btn" data-dir="left">◀</button>
          <button id="btn-right" class="control-btn" data-dir="right">▶</button>
          <button id="btn-down" class="control-btn" data-dir="down">▼</button>
        </div>
        
        <button id="start-btn" style="margin-top: 15px; width: 100%;">START GAME</button>
        <button id="sound-btn" style="margin-top: 5px; width: 100%;">SOUND: ON</button>
      </div>
    </div>
  </div>

  <script>
    // Enhanced Audio System
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let soundEnabled = true;

    function createTone(frequency, duration, type = 'square', volume = 0.1) {
      if (!soundEnabled) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      oscillator.type = type;
      
      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }

    const sounds = {
      chomp: () => {
        createTone(800, 0.1);
        setTimeout(() => createTone(600, 0.1), 50);
      },
      powerup: () => {
        createTone(1000, 0.2, 'sine');
        setTimeout(() => createTone(1200, 0.2, 'sine'), 100);
        setTimeout(() => createTone(1400, 0.3, 'sine'), 200);
      },
      death: () => {
        for (let i = 0; i < 10; i++) {
          setTimeout(() => createTone(400 - i * 30, 0.1), i * 50);
        }
      },
      eatGhost: () => {
        createTone(400, 0.5, 'sawtooth', 0.15);
      },
      levelComplete: () => {
        const notes = [523, 659, 784, 1047];
        notes.forEach((note, i) => {
          setTimeout(() => createTone(note, 0.3, 'sine'), i * 150);
        });
      }
    };

    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');

    // Grid-based movement system
    const COLS = 27;
    const ROWS = 31;
    const TILE = 18;
    const VIRTUAL_W = COLS * TILE;
    const VIRTUAL_H = ROWS * TILE;

    // Game state
    let gameRunning = false;
    let currentLevel = 1;
    let score = 0;
    let lives = 3;
    let pelletsRemaining = 0;
    let powerUpActive = false;
    let powerUpTimer = 0;

    // Enhanced maze generation
    function generateMap() {
      const newMap = new Array(ROWS).fill(0).map(() => new Array(COLS).fill(0));
      
      // Create border walls
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
            newMap[r][c] = 1; // wall
          }
        }
      }
      
      // Create internal maze structure
      for (let r = 2; r < ROWS - 2; r += 2) {
        for (let c = 2; c < COLS - 2; c += 2) {
          if (Math.random() > 0.3) {
            newMap[r][c] = 1;
            // Add connecting walls
            if (Math.random() > 0.5 && c < COLS - 3) newMap[r][c + 1] = 1;
            if (Math.random() > 0.5 && r < ROWS - 3) newMap[r + 1][c] = 1;
          }
        }
      }
      
      // Ghost home area (center)
      const centerR = Math.floor(ROWS / 2);
      const centerC = Math.floor(COLS / 2);
      for (let r = centerR - 2; r <= centerR + 2; r++) {
        for (let c = centerC - 3; c <= centerC + 3; c++) {
          if (r === centerR - 2 || r === centerR + 2 || c === centerC - 3 || c === centerC + 3) {
            newMap[r][c] = 1;
          } else {
            newMap[r][c] = 0;
          }
        }
      }
      
      // Add pellets and power-ups
      pelletsRemaining = 0;
      for (let r = 1; r < ROWS - 1; r++) {
        for (let c = 1; c < COLS - 1; c++) {
          if (newMap[r][c] === 0) {
            // Skip starting areas
            if ((r < 3 && c < 3) || (r > centerR - 3 && r < centerR + 3 && c > centerC - 4 && c < centerC + 4)) {
              continue;
            }
            
            // 5% chance for power-up, otherwise pellet
            if (Math.random() < 0.05) {
              newMap[r][c] = 3; // power-up
            } else {
              newMap[r][c] = 2; // pellet
            }
            pelletsRemaining++;
          }
        }
      }
      
      return newMap;
    }

    let map = generateMap();

    // Grid-based player
    const player = {
      gridX: 1,
      gridY: 1,
      x: TILE * 1.5,
      y: TILE * 1.5,
      radius: TILE * 0.35,
      dir: null,
      nextDir: null,
      speed: 4, // tiles per second
      moving: false,
      moveProgress: 0
    };

    // Enhanced Ghost AI with proper pathfinding
    const ghostColors = ['#ff0000', '#ffb8ff', '#00ffff', '#ffb852', '#00ff00'];
    const ghostNames = ['Blinky', 'Pinky', 'Inky', 'Clyde', 'Sue'];
    let ghosts = [];

    function createGhost(index, level) {
      const centerR = Math.floor(ROWS / 2);
      const centerC = Math.floor(COLS / 2);
      
      const startPositions = [
        {gridX: centerC - 1, gridY: centerR},
        {gridX: centerC + 1, gridY: centerR},
        {gridX: centerC, gridY: centerR - 1},
        {gridX: centerC, gridY: centerR + 1},
        {gridX: centerC - 2, gridY: centerR}
      ];
      
      const pos = startPositions[index % 5];
      
      return {
        gridX: pos.gridX,
        gridY: pos.gridY,
        x: pos.gridX * TILE + TILE / 2,
        y: pos.gridY * TILE + TILE / 2,
        radius: TILE * 0.32,
        dir: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
        speed: 3 + level * 0.3, // tiles per second
        color: ghostColors[index % 5],
        name: ghostNames[index % 5],
        mode: 'chase', // chase, scatter, frightened
        modeTimer: 0,
        moving: false,
        moveProgress: 0,
        frightened: false,
        frightenedTimer: 0
      };
    }

    // A* pathfinding for ghosts
    function findPath(startX, startY, targetX, targetY) {
      const openSet = [{x: startX, y: startY, g: 0, h: 0, f: 0, parent: null}];
      const closedSet = [];
      
      while (openSet.length > 0) {
        openSet.sort((a, b) => a.f - b.f);
        const current = openSet.shift();
        closedSet.push(current);
        
        if (current.x === targetX && current.y === targetY) {
          const path = [];
          let node = current;
          while (node.parent) {
            path.unshift({x: node.x, y: node.y});
            node = node.parent;
          }
          return path;
        }
        
        const neighbors = [
          {x: current.x + 1, y: current.y},
          {x: current.x - 1, y: current.y},
          {x: current.x, y: current.y + 1},
          {x: current.x, y: current.y - 1}
        ];
        
        for (const neighbor of neighbors) {
          if (neighbor.x < 0 || neighbor.x >= COLS || neighbor.y < 0 || neighbor.y >= ROWS) continue;
          if (map[neighbor.y][neighbor.x] === 1) continue;
          if (closedSet.find(n => n.x === neighbor.x && n.y === neighbor.y)) continue;
          
          const g = current.g + 1;
          const h = Math.abs(neighbor.x - targetX) + Math.abs(neighbor.y - targetY);
          const f = g + h;
          
          const existing = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
          if (!existing || g < existing.g) {
            if (existing) {
              existing.g = g;
              existing.f = f;
              existing.parent = current;
            } else {
              openSet.push({x: neighbor.x, y: neighbor.y, g, h, f, parent: current});
            }
          }
        }
      }
      
      return []; // No path found
    }

    function updateHUD() {
      document.getElementById('score-display').textContent = score;
      document.getElementById('level-display').textContent = currentLevel;
      document.getElementById('pellets-display').textContent = pelletsRemaining;
      
      const livesContainer = document.getElementById('lives-display');
      livesContainer.innerHTML = '';
      for (let i = 0; i < lives; i++) {
        const lifeIcon = document.createElement('div');
        lifeIcon.className = 'life-icon';
        livesContainer.appendChild(lifeIcon);
      }
      
      const powerupStatus = document.getElementById('powerup-status');
      if (powerUpActive) {
        powerupStatus.innerHTML = `<div class="powerup-timer">POWER: ${Math.ceil(powerUpTimer)}s</div>`;
      } else {
        powerupStatus.innerHTML = '';
      }
    }

    function initializeLevel(level) {
      map = generateMap();
      
      // Reset player to grid position
      player.gridX = 1;
      player.gridY = 1;
      player.x = TILE * 1.5;
      player.y = TILE * 1.5;
      player.dir = null;
      player.nextDir = null;
      player.moving = false;
      player.moveProgress = 0;
      
      // Create 4-5 ghosts based on level
      ghosts = [];
      const numGhosts = Math.min(5, 3 + Math.floor(level / 3));
      for (let i = 0; i < numGhosts; i++) {
        ghosts.push(createGhost(i, level));
      }
      
      powerUpActive = false;
      powerUpTimer = 0;
      
      updateHUD();
    }

    function resizeCanvas() {
      const container = document.getElementById('game-area');
      const maxW = container.clientWidth - 40;
      const maxH = container.clientHeight - 40;
      
      const scale = Math.min(maxW / VIRTUAL_W, maxH / VIRTUAL_H);
      const displayW = Math.floor(VIRTUAL_W * scale);
      const displayH = Math.floor(VIRTUAL_H * scale);
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      canvas.style.width = displayW + 'px';
      canvas.style.height = displayH + 'px';
      canvas.width = Math.floor(displayW * dpr);
      canvas.height = Math.floor(displayH * dpr);

      ctx.setTransform(dpr * scale, 0, 0, dpr * scale, 0, 0);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const keys = {};
    window.addEventListener('keydown', e => {
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      
      const mapKey = {ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', a:'left', s:'down', d:'right'}[e.key];
      if (mapKey) { keys[mapKey] = true; e.preventDefault(); }
    });
    window.addEventListener('keyup', e => {
      const mapKey = {ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', a:'left', s:'down', d:'right'}[e.key];
      if (mapKey) keys[mapKey] = false;
    });

    document.querySelectorAll('.control-btn').forEach(btn => {
      const dir = btn.dataset.dir;
      btn.addEventListener('touchstart', e => { 
        keys[dir] = true; 
        e.preventDefault();
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
      }, {passive:false});
      btn.addEventListener('touchend', e => { keys[dir] = false; e.preventDefault(); }, {passive:false});
      btn.addEventListener('mousedown', e => { keys[dir] = true; e.preventDefault(); });
      btn.addEventListener('mouseup', e => { keys[dir] = false; e.preventDefault(); });
    });

    document.getElementById('sound-btn').addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      document.getElementById('sound-btn').textContent = `SOUND: ${soundEnabled ? 'ON' : 'OFF'}`;
    });

    function canMoveTo(gridX, gridY) {
      if (gridX < 0 || gridX >= COLS || gridY < 0 || gridY >= ROWS) return false;
      return map[gridY][gridX] !== 1;
    }

    function updatePlayer(dt) {
      // Handle direction input
      const desire = keys.up ? 'up' : keys.down ? 'down' : keys.left ? 'left' : keys.right ? 'right' : null;
      if (desire) player.nextDir = desire;
      
      if (!player.moving) {
        // Try to start moving in desired direction
        if (player.nextDir) {
          let newGridX = player.gridX;
          let newGridY = player.gridY;
          
          switch (player.nextDir) {
            case 'up': newGridY--; break;
            case 'down': newGridY++; break;
            case 'left': newGridX--; break;
            case 'right': newGridX++; break;
          }
          
          if (canMoveTo(newGridX, newGridY)) {
            player.dir = player.nextDir;
            player.nextDir = null;
            player.moving = true;
            player.moveProgress = 0;
          }
        }
        
        // Try to continue in current direction
        if (!player.moving && player.dir) {
          let newGridX = player.gridX;
          let newGridY = player.gridY;
          
          switch (player.dir) {
            case 'up': newGridY--; break;
            case 'down': newGridY++; break;
            case 'left': newGridX--; break;
            case 'right': newGridX++; break;
          }
          
          if (canMoveTo(newGridX, newGridY)) {
            player.moving = true;
            player.moveProgress = 0;
          }
        }
      }
      
      if (player.moving) {
        player.moveProgress += player.speed * dt;
        
        if (player.moveProgress >= 1) {
          // Complete the move
          switch (player.dir) {
            case 'up': player.gridY--; break;
            case 'down': player.gridY++; break;
            case 'left': player.gridX--; break;
            case 'right': player.gridX++; break;
          }
          
          player.moving = false;
          player.moveProgress = 0;
          
          // Check for pellets/powerups
          const tile = map[player.gridY][player.gridX];
          if (tile === 2) {
            map[player.gridY][player.gridX] = 0;
            score += 10 * currentLevel;
            pelletsRemaining--;
            sounds.chomp();
            updateHUD();
          } else if (tile === 3) {
            map[player.gridY][player.gridX] = 0;
            score += 50 * currentLevel;
            pelletsRemaining--;
            powerUpActive = true;
            powerUpTimer = 8; // 8 seconds of power
            sounds.powerup();
            
            // Make all ghosts frightened
            ghosts.forEach(ghost => {
              ghost.frightened = true;
              ghost.frightenedTimer = 8;
            });
            
            updateHUD();
          }
        }
        
        // Update visual position
        const startX = player.gridX * TILE + TILE / 2;
        const startY = player.gridY * TILE + TILE / 2;
        let targetX = startX, targetY = startY;
        
        switch (player.dir) {
          case 'up': targetY = startY - TILE; break;
          case 'down': targetY = startY + TILE; break;
          case 'left': targetX = startX - TILE; break;
          case 'right': targetX = startX + TILE; break;
        }
        
        player.x = startX + (targetX - startX) * player.moveProgress;
        player.y = startY + (targetY - startY) * player.moveProgress;
      } else {
        player.x = player.gridX * TILE + TILE / 2;
        player.y = player.gridY * TILE + TILE / 2;
      }
    }

    function updateGhost(ghost, dt) {
      ghost.modeTimer += dt;
      if (ghost.frightenedTimer > 0) {
        ghost.frightenedTimer -= dt;
        if (ghost.frightenedTimer <= 0) {
          ghost.frightened = false;
        }
      }
      
      if (!ghost.moving) {
        let targetX = player.gridX;
        let targetY = player.gridY;
        
        if (ghost.frightened) {
          // Run away from player
          targetX = ghost.gridX + (ghost.gridX - player.gridX);
          targetY = ghost.gridY + (ghost.gridY - player.gridY);
        } else {
          // Different AI behaviors
          switch (ghost.name) {
            case 'Blinky': // Direct chase
              break;
            case 'Pinky': // Ambush (4 tiles ahead)
              switch (player.dir) {
                case 'up': targetY -= 4; break;
                case 'down': targetY += 4; break;
                case 'left': targetX -= 4; break;
                case 'right': targetX += 4; break;
              }
              break;
            case 'Inky': // Complex behavior
              targetX = player.gridX + Math.floor(Math.random() * 6 - 3);
              targetY = player.gridY + Math.floor(Math.random() * 6 - 3);
              break;
            case 'Clyde': // Keep distance
              const dist = Math.abs(ghost.gridX - player.gridX) + Math.abs(ghost.gridY - player.gridY);
              if (dist < 8) {
                targetX = ghost.gridX + (ghost.gridX - player.gridX);
                targetY = ghost.gridY + (ghost.gridY - player.gridY);
              }
              break;
            case 'Sue': // Patrol behavior
              if (ghost.modeTimer > 5) {
                ghost.modeTimer = 0;
                targetX = Math.floor(Math.random() * COLS);
                targetY = Math.floor(Math.random() * ROWS);
              }
              break;
          }
        }
        
        // Clamp target to valid range
        targetX = Math.max(0, Math.min(COLS - 1, targetX));
        targetY = Math.max(0, Math.min(ROWS - 1, targetY));
        
        // Find path to target
        const path = findPath(ghost.gridX, ghost.gridY, targetX, targetY);
        if (path.length > 0) {
          const nextStep = path[0];
          const dx = nextStep.x - ghost.gridX;
          const dy = nextStep.y - ghost.gridY;
          
          if (dx > 0) ghost.dir = 'right';
          else if (dx < 0) ghost.dir = 'left';
          else if (dy > 0) ghost.dir = 'down';
          else if (dy < 0) ghost.dir = 'up';
          
          ghost.moving = true;
          ghost.moveProgress = 0;
        }
      }
      
      if (ghost.moving) {
        const moveSpeed = ghost.frightened ? ghost.speed * 0.5 : ghost.speed;
        ghost.moveProgress += moveSpeed * dt;
        
        if (ghost.moveProgress >= 1) {
          switch (ghost.dir) {
            case 'up': ghost.gridY--; break;
            case 'down': ghost.gridY++; break;
            case 'left': ghost.gridX--; break;
            case 'right': ghost.gridX++; break;
          }
          
          ghost.moving = false;
          ghost.moveProgress = 0;
        }
        
        // Update visual position
        const startX = ghost.gridX * TILE + TILE / 2;
        const startY = ghost.gridY * TILE + TILE / 2;
        let targetX = startX, targetY = startY;
        
        switch (ghost.dir) {
          case 'up': targetY = startY - TILE; break;
          case 'down': targetY = startY + TILE; break;
          case
