/* Minimal responsive Pac-like starter
   - Virtual grid with scaling to fit viewport
   - Basic movement with collisions
   - Touch and keyboard controls
*/

(() => {
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');

  // Virtual grid size (tiles)
  const COLS = 19;
  const ROWS = 21;
  const TILE = 16; // virtual tile px
  const VIRTUAL_W = COLS * TILE;
  const VIRTUAL_H = ROWS * TILE;

  // Simple map: 0 = empty, 1 = wall, 2 = pellet
  // For brevity: generate a frame of walls and pellets for interior
  const map = new Array(ROWS).fill(0).map((_, r) => {
    return new Array(COLS).fill(2).map((_, c) => {
      if (r === 0 || r === ROWS-1 || c === 0 || c === COLS-1) return 1;
      if ((r % 4 === 0) && (c % 4 === 0)) return 1;
      return 2;
    });
  });

  // Player state
  const player = {
    x: TILE * 1.5,
    y: TILE * 1.5,
    radius: TILE * 0.45,
    dir: null,           // 'up','down','left','right'
    nextDir: null,
    speed: 80,           // virtual pixels per second
  };

  // Resize and scaling
  function resizeCanvas() {
    // compute scale so game fits while preserving aspect ratio
    const scale = Math.min(window.innerWidth / VIRTUAL_W, window.innerHeight / VIRTUAL_H);
    const displayW = Math.floor(VIRTUAL_W * scale);
    const displayH = Math.floor(VIRTUAL_H * scale);

    // use devicePixelRatio for crisp rendering
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.style.width = displayW + 'px';
    canvas.style.height = displayH + 'px';
    canvas.width = Math.floor(displayW * dpr);
    canvas.height = Math.floor(displayH * dpr);

    ctx.setTransform(dpr * scale, 0, 0, dpr * scale, 0, 0); // scale drawing to virtual coords
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Input
  const keys = {};
  window.addEventListener('keydown', e => {
    const mapKey = {ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', a:'left', s:'down', d:'right'}[e.key];
    if (mapKey) { keys[mapKey] = true; e.preventDefault(); }
  });
  window.addEventListener('keyup', e => {
    const mapKey = {ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', a:'left', s:'down', d:'right'}[e.key];
    if (mapKey) keys[mapKey] = false;
  });

  // Touch controls (on-screen buttons)
  document.querySelectorAll('#touch-controls .dir').forEach(btn => {
    const dir = btn.dataset.dir;
    btn.addEventListener('touchstart', e => { keys[dir] = true; e.preventDefault(); });
    btn.addEventListener('touchend', e => { keys[dir] = false; e.preventDefault(); });
    btn.addEventListener('mousedown', e => { keys[dir] = true; e.preventDefault(); });
    btn.addEventListener('mouseup', e => { keys[dir] = false; e.preventDefault(); });
  });

  // Swipe support (simple)
  (function addSwipe(el = document.body) {
    let sx=0, sy=0, threshold=20;
    el.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; }, {passive:true});
    el.addEventListener('touchend', e=>{
      const t=e.changedTouches[0]; const dx=t.clientX - sx; const dy=t.clientY - sy;
      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
        keys.left = dx<0; keys.right = dx>0;
        setTimeout(()=>{ keys.left = keys.right = false; }, 120);
      } else if (Math.abs(dy) > threshold) {
        keys.up = dy<0; keys.down = dy>0;
        setTimeout(()=>{ keys.up = keys.down = false; }, 120);
      }
    }, {passive:true});
  })();

  // Utility: check tile at (col,row)
  function tileAtColRow(col,row){ return (row<0||row>=ROWS||col<0||col>=COLS) ? 1 : map[row][col]; }

  // Collision test for proposed position (circle vs grid walls)
  function collides(x,y,r) {
    const left = Math.floor((x - r) / TILE);
    const right = Math.floor((x + r) / TILE);
    const top = Math.floor((y - r) / TILE);
    const bottom = Math.floor((y + r) / TILE);
    for (let rr=top; rr<=bottom; rr++){
      for (let cc=left; cc<=right; cc++){
        if (tileAtColRow(cc,rr) === 1) return true;
      }
    }
    return false;
  }

  // Game loop
  let last = performance.now();
  function step(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(step);
  }

  // Update player movement
  function update(dt) {
    // Resolve desired direction from keys
    const desire = keys.up ? 'up' : keys.down ? 'down' : keys.left ? 'left' : keys.right ? 'right' : null;
    if (desire) player.nextDir = desire;
    // apply nextDir if possible (snap to grid)
    if (player.nextDir) {
      const dir = player.nextDir;
      const vx = dir === 'left' ? -1 : dir === 'right' ? 1 : 0;
      const vy = dir === 'up' ? -1 : dir === 'down' ? 1 : 0;
      const speed = player.speed;
      const nx = player.x + vx * speed * dt;
      const ny = player.y + vy * speed * dt;
      if (!collides(nx, ny, player.radius - 1)) {
        player.dir = player.nextDir;
        player.nextDir = null;
      }
    }

    // Move according to current dir
    if (player.dir) {
      const vx = player.dir === 'left' ? -1 : player.dir === 'right' ? 1 : 0;
      const vy = player.dir === 'up' ? -1 : player.dir === 'down' ? 1 : 0;
      const nx = player.x + vx * player.speed * dt;
      const ny = player.y + vy * player.speed * dt;
      if (!collides(nx, ny, player.radius - 1)) {
        player.x = nx; player.y = ny;
      } else {
        // stop if colliding
        player.dir = null;
      }
    }

    // Eat pellets if present
    const col = Math.floor(player.x / TILE);
    const row = Math.floor(player.y / TILE);
    if (map[row] && map[row][col] === 2) map[row][col] = 0;
  }

  // Render
  function render() {
    ctx.clearRect(0,0,VIRTUAL_W, VIRTUAL_H);

    // Background
    ctx.fillStyle = '#05102b';
    ctx.fillRect(0,0,VIRTUAL_W, VIRTUAL_H);

    // Draw map
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const t = map[r][c];
        const x = c * TILE;
        const y = r * TILE;
        if (t === 1) {
          ctx.fillStyle = '#003366';
          roundRect(ctx, x+1, y+1, TILE-2, TILE-2, 3);
          ctx.fill();
        } else if (t === 2) {
          ctx.fillStyle = '#ffd966';
          const cx = x + TILE/2, cy = y + TILE/2;
          ctx.beginPath();
          ctx.arc(cx, cy, Math.max(1, TILE*0.12), 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // Draw player (simple circle with mouth)
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = '#ffcc00';
    // simple chomping animation based on time
    const t = performance.now() / 200;
    const mouth = Math.abs(Math.sin(t)) * 0.3 + 0.05;
    let ang = 0;
    if (player.dir === 'left') ang = Math.PI;
    else if (player.dir === 'up') ang = -Math.PI/2;
    else if (player.dir === 'down') ang = Math.PI/2;
    const start = mouth * Math.PI + ang;
    const end = (2 - mouth) * Math.PI + ang;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0, player.radius, start, end, false);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // util: rounded rect
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Controls for start button
  document.getElementById('start-btn').addEventListener('click', ()=> {
    player.x = TILE*1.5; player.y = TILE*1.5; player.dir = null;
    last = performance.now();
    requestAnimationFrame(step);
    document.getElementById('status').textContent = 'Playing';
  });

  // Start automatically
  document.getElementById('start-btn').click();
})();
